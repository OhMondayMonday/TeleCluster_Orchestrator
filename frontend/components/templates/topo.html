<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Topolog√≠as de Red - VNRT</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header-section {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .header-section h2 {
            font-size: 20px;
            color: #333;
            margin-bottom: 15px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-group label {
            font-size: 14px;
            color: #666;
            min-width: 100px;
        }

        .control-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #2196F3;
            color: white;
        }

        .btn-primary:hover {
            background: #1976D2;
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-success:hover {
            background: #388E3C;
        }

        .btn-warning {
            background: #FF9800;
            color: white;
        }

        .btn-warning:hover {
            background: #F57C00;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .templates {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #fafafa;
        }

        .templates h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }

        .template-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .template-btn {
            padding: 10px 20px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .template-btn:hover {
            border-color: #4CAF50;
            background: #E8F5E9;
        }

        .canvas-section {
            padding: 20px;
            min-height: 500px;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 500px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            position: relative;
            overflow: auto;
            background: #f9f9f9;
        }

        #canvas {
            width: 3000px;
            height: 3000px;
            position: relative;
            background: white;
            background-image:
                linear-gradient(0deg, transparent 24%, rgba(0, 0, 0, 0.02) 25%, rgba(0, 0, 0, 0.02) 26%, transparent 27%, transparent 74%, rgba(0, 0, 0, 0.02) 75%, rgba(0, 0, 0, 0.02) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(0, 0, 0, 0.02) 25%, rgba(0, 0, 0, 0.02) 26%, transparent 27%, transparent 74%, rgba(0, 0, 0, 0.02) 75%, rgba(0, 0, 0, 0.02) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
            transform-origin: 0 0;
        }

        .zoom-controls {
            position: absolute;
            bottom: 40px;
            right: 40px;
            display: flex;
            gap: 5px;
            z-index: 10;
            background: white;
            padding: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: #f5f5f5;
        }

        .zoom-level {
            padding: 0 10px;
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #666;
        }

        .node {
            position: absolute;
            width: 60px;
            height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: move;
            user-select: none;
        }

        .node-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: white;
            border: 2px solid #4CAF50;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .node.router .node-icon {
            background: #FF9800;
            border-color: #F57C00;
            color: white;
        }

        .node.switch .node-icon {
            background: #2196F3;
            border-color: #1976D2;
            color: white;
        }

        .node.server .node-icon {
            background: #9C27B0;
            border-color: #7B1FA2;
            color: white;
        }

        .node-label {
            margin-top: 5px;
            font-size: 11px;
            background: white;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #ddd;
        }

        .node.selected {
            filter: drop-shadow(0 0 5px #FF9800);
        }

        .connection {
            position: absolute;
            background: #4CAF50;
            height: 2px;
            transform-origin: left center;
            z-index: 0;
        }

        .connection-label {
            position: absolute;
            background: white;
            padding: 2px 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 10px;
            z-index: 1;
        }

        .node-menu {
            position: absolute;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 100;
            display: none;
            min-width: 120px;
        }

        .node-menu.active {
            display: block;
        }

        .node-menu button {
            display: block;
            width: 100%;
            padding: 8px 16px;
            border: none;
            background: white;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
        }

        .node-menu button:hover {
            background: #f5f5f5;
        }

        .info-panel {
            padding: 20px;
            border-top: 1px solid #e0e0e0;
            background: #fafafa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stats {
            display: flex;
            gap: 20px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
        }

        .stat-item strong {
            color: #333;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .modal-body {
            margin: 15px 0;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: 500;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .modal-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header-section">
            <h2>Editor de Topolog√≠as de Red</h2>
            <div class="controls">
                <div class="control-group">
                    <label>Nombre:</label>
                    <input type="text" id="topologyName" placeholder="Mi Topolog√≠a">
                </div>
                <div class="control-group">
                    <label>Descripci√≥n:</label>
                    <input type="text" id="topologyDescription" placeholder="Descripci√≥n del slice">
                </div>
                <button class="btn btn-primary" onclick="addNode()">A√±adir Nodo</button>
                <button class="btn btn-primary" onclick="enableLinkMode()">Conectar Nodos</button>
                <button class="btn btn-warning" onclick="exportJSON()">Exportar JSON</button>
                <input type="file" id="fileInput" accept=".json" onchange="importJSON(this)" style="display:none">
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">Importar</button>
                <button class="btn btn-danger" onclick="clearAll()">Limpiar</button>
            </div>
        </div>

        <div class="templates">
            <h3>Topolog√≠as Predefinidas</h3>
            <div class="template-buttons">
                <button class="template-btn" onclick="showTopologyModal('star')">Estrella</button>
                <button class="template-btn" onclick="showTopologyModal('tree')">√Årbol</button>
                <button class="template-btn" onclick="showTopologyModal('ring')">Anillo</button>
                <button class="template-btn" onclick="showTopologyModal('mesh')">Malla</button>
                <button class="template-btn" onclick="showTopologyModal('bus')">Bus</button>
                <button class="template-btn" onclick="showTopologyModal('fullmesh')">Full Mesh</button>
            </div>
        </div>

        <div class="canvas-section">
            <div id="canvas-container">
                <div id="canvas"></div>
            </div>
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
                <span class="zoom-level" id="zoomLevel">100%</span>
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="resetZoom()">‚ü≤</button>
            </div>
        </div>

        <div class="info-panel">
            <div class="stats">
                <div class="stat-item">
                    <span>Nodos:</span>
                    <strong id="nodeCount">0</strong>
                </div>
                <div class="stat-item">
                    <span>Enlaces:</span>
                    <strong id="linkCount">0</strong>
                </div>
                <div class="stat-item">
                    <span>Topolog√≠a:</span>
                    <strong id="topologyType">Personalizada</strong>
                </div>
            </div>
            <div>
                <button class="btn btn-success" onclick="validateTopology()">Validar</button>
                <button class="btn btn-success" onclick="sendToSliceManager()">Enviar a Slice Manager</button>
            </div>
        </div>
    </div>

    <div class="node-menu" id="nodeMenu">
        <button onclick="editNodeFromMenu()">Editar</button>
        <button onclick="deleteNodeFromMenu()">Eliminar</button>
    </div>

    <div class="modal" id="nodeModal">
        <div class="modal-content">
            <div class="modal-header">Configurar Nodo</div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Nombre:</label>
                    <input type="text" id="nodeName" placeholder="Nodo 0">
                </div>
                <div class="form-group">
                    <label>Tipo:</label>
                    <select id="nodeType">
                        <option value="pc">PC/Host</option>
                        <option value="router">Router</option>
                        <option value="switch">Switch</option>
                        <option value="server">Server</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Imagen:</label>
                    <select id="nodeImage">
                        <option value="cirros">cirros</option>
                        <option value="ubuntu">ubuntu</option>
                        <option value="centos">centos</option>
                        <option value="debian">debian</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Flavor:</label>
                    <select id="nodeFlavor">
                        <option value="2GBRAM_2VCPUS_10GBRoot">2GB RAM, 2 vCPUs, 10GB Root</option>
                        <option value="4GBRAM_2VCPUS_20GBRoot">4GB RAM, 2 vCPUs, 20GB Root</option>
                        <option value="8GBRAM_4VCPUS_40GBRoot">8GB RAM, 4 vCPUs, 40GB Root</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('nodeModal')">Cancelar</button>
                <button class="btn btn-success" onclick="saveNode()">Guardar</button>
            </div>
        </div>
    </div>

    <div class="modal" id="topologyModal">
        <div class="modal-content">
            <div class="modal-header">Agregar Topolog√≠a <span id="topologyModalType"></span></div>
            <div class="modal-body" id="topologyModalBody"></div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('topologyModal')">Cancelar</button>
                <button class="btn btn-success" onclick="createTopology()">Crear</button>
            </div>
        </div>
    </div>

    <script>
        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let connectionIdCounter = 0;
        let linkMode = false;
        let linkSource = null;
        let currentEditNode = null;
        let currentTopologyType = null;
        let draggedNode = null;
        let currentMenuNode = null;
        let zoomLevel = 1;
        let canvasContainer = null;
        let visibleX = 0;
        let visibleY = 0;

        const SLICE_MANAGER_CONFIG = {
            url: 'http://localhost:5000/api/topology',
            apiKey: ''
        };

        function addNode() {
            updateVisibleArea();
            createNodeAt(visibleX + 250, visibleY + 250);
        }

        function updateVisibleArea() {
            canvasContainer = canvasContainer || document.getElementById('canvas-container');
            visibleX = canvasContainer.scrollLeft / zoomLevel;
            visibleY = canvasContainer.scrollTop / zoomLevel;
        }

        function createNodeAt(x, y, config = {}) {
            const nodeId = `node-${nodeIdCounter++}`;
            const node = {
                id: nodeId,
                name: config.name || `Nodo ${nodes.length}`,
                type: config.type || 'pc',
                image: config.image || 'cirros',
                flavor: config.flavor || '2GBRAM_2VCPUS_10GBRoot',
                x: x - 30,
                y: y - 40,
                interfaces: []
            };

            nodes.push(node);
            renderNode(node);
            updateStats();
            return node;
        }

        function renderNode(node) {
            const canvas = document.getElementById('canvas');
            const nodeDiv = document.createElement('div');
            nodeDiv.className = `node ${node.type}`;
            nodeDiv.id = node.id;
            nodeDiv.style.left = `${node.x}px`;
            nodeDiv.style.top = `${node.y}px`;

            const icons = {
                pc: 'üíª',
                router: 'üì°',
                switch: 'üîå',
                server: 'üñ•Ô∏è'
            };

            nodeDiv.innerHTML = `
                <div class="node-icon">${icons[node.type]}</div>
                <div class="node-label">${node.name}</div>
            `;

            nodeDiv.addEventListener('mousedown', startDrag);
            nodeDiv.addEventListener('click', (e) => {
                e.stopPropagation();
                if (linkMode) {
                    handleLinkClick(node);
                } else {
                    showNodeMenu(e, node);
                }
            });

            canvas.appendChild(nodeDiv);
        }

        function showNodeMenu(e, node) {
            e.preventDefault();
            e.stopPropagation();
            if (linkMode) return;

            currentMenuNode = node;
            const menu = document.getElementById('nodeMenu');
            menu.style.left = `${e.pageX}px`;
            menu.style.top = `${e.pageY}px`;
            menu.classList.add('active');
        }

        function editNodeFromMenu() {
            if (currentMenuNode) {
                editNode(currentMenuNode);
                hideNodeMenu();
            }
        }

        function deleteNodeFromMenu() {
            if (currentMenuNode) {
                deleteNode(currentMenuNode);
                hideNodeMenu();
            }
        }

        function hideNodeMenu() {
            document.getElementById('nodeMenu').classList.remove('active');
            currentMenuNode = null;
        }

        function deleteNode(node) {
            connections = connections.filter(conn => {
                if (conn.from === node.id || conn.to === node.id) {
                    document.getElementById(conn.id)?.remove();
                    document.getElementById(`${conn.id}-label`)?.remove();
                    return false;
                }
                return true;
            });

            nodes.forEach(n => {
                n.interfaces = n.interfaces.filter(intId => {
                    const conn = connections.find(c => c.id === intId);
                    return conn !== undefined;
                });
            });

            document.getElementById(node.id)?.remove();
            nodes = nodes.filter(n => n.id !== node.id);
            updateStats();
        }

        function startDrag(e) {
            if (linkMode) return;

            const nodeDiv = e.currentTarget;
            const node = nodes.find(n => n.id === nodeDiv.id);
            draggedNode = node;

            const startX = e.clientX - node.x;
            const startY = e.clientY - node.y;

            function onMouseMove(e) {
                node.x = e.clientX - startX;
                node.y = e.clientY - startY;
                nodeDiv.style.left = `${node.x}px`;
                nodeDiv.style.top = `${node.y}px`;
                updateConnections();
            }

            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                draggedNode = null;
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function enableLinkMode() {
            linkMode = true;
            linkSource = null;
            document.getElementById('canvas').style.cursor = 'crosshair';
        }

        function handleLinkClick(node) {
            if (!linkSource) {
                linkSource = node;
                document.getElementById(node.id).classList.add('selected');
            } else if (linkSource.id !== node.id) {
                createConnection(linkSource, node);
                document.getElementById(linkSource.id).classList.remove('selected');
                linkSource = null;
                linkMode = false;
                document.getElementById('canvas').style.cursor = 'default';
            }
        }

        function createConnection(node1, node2) {
            const exists = connections.find(c =>
                (c.from === node1.id && c.to === node2.id) ||
                (c.from === node2.id && c.to === node1.id)
            );

            if (!exists) {
                const connectionId = `link-${connectionIdCounter++}`;
                const connection = {
                    id: connectionId,
                    name: `Enlace ${connections.length}`,
                    from: node1.id,
                    to: node2.id
                };

                connections.push(connection);
                renderConnection(connection);

                node1.interfaces.push(connectionId);
                node2.interfaces.push(connectionId);

                updateStats();
            }
        }

        function renderConnection(connection) {
            const canvas = document.getElementById('canvas');
            const node1 = nodes.find(n => n.id === connection.from);
            const node2 = nodes.find(n => n.id === connection.to);

            const line = document.createElement('div');
            line.className = 'connection';
            line.id = connection.id;

            const label = document.createElement('div');
            label.className = 'connection-label';
            label.id = `${connection.id}-label`;
            label.textContent = connection.name;

            canvas.appendChild(line);
            canvas.appendChild(label);

            updateConnectionPosition(connection);
        }

        function updateConnectionPosition(connection) {
            const line = document.getElementById(connection.id);
            const label = document.getElementById(`${connection.id}-label`);
            const node1 = nodes.find(n => n.id === connection.from);
            const node2 = nodes.find(n => n.id === connection.to);

            const x1 = node1.x + 30;
            const y1 = node1.y + 30;
            const x2 = node2.x + 30;
            const y2 = node2.y + 30;

            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transform = `rotate(${angle}deg)`;

            label.style.left = `${(x1 + x2) / 2 - 20}px`;
            label.style.top = `${(y1 + y2) / 2 - 10}px`;
        }

        function updateConnections() {
            connections.forEach(connection => {
                updateConnectionPosition(connection);
            });
        }

        function editNode(node) {
            currentEditNode = node;
            document.getElementById('nodeName').value = node.name;
            document.getElementById('nodeType').value = node.type;
            document.getElementById('nodeImage').value = node.image;
            document.getElementById('nodeFlavor').value = node.flavor;
            document.getElementById('nodeModal').classList.add('active');
        }

        function saveNode() {
            if (currentEditNode) {
                currentEditNode.name = document.getElementById('nodeName').value;
                currentEditNode.type = document.getElementById('nodeType').value;
                currentEditNode.image = document.getElementById('nodeImage').value;
                currentEditNode.flavor = document.getElementById('nodeFlavor').value;

                const nodeDiv = document.getElementById(currentEditNode.id);
                nodeDiv.className = `node ${currentEditNode.type}`;
                const icons = {
                    pc: 'üíª',
                    router: 'üì°',
                    switch: 'üîå',
                    server: 'üñ•Ô∏è'
                };
                nodeDiv.querySelector('.node-icon').textContent = icons[currentEditNode.type];
                nodeDiv.querySelector('.node-label').textContent = currentEditNode.name;

                closeModal('nodeModal');
            }
        }

        function showTopologyModal(type) {
            currentTopologyType = type;
            const modalBody = document.getElementById('topologyModalBody');
            document.getElementById('topologyModalType').textContent = type.charAt(0).toUpperCase() + type.slice(1);

            let html = '';
            switch (type) {
                case 'star':
                case 'ring':
                case 'bus':
                    html = `<div class="form-group"><label>N√∫mero de nodos:</label><input type="number" id="paramNodes" value="5" min="2" max="20"></div>`;
                    break;
                case 'tree':
                    html = `<div class="form-group"><label>Niveles:</label><input type="number" id="paramLevels" value="3" min="2" max="5"></div>`;
                    break;
                case 'mesh':
                    html = `<div class="form-group"><label>Filas:</label><input type="number" id="paramRows" value="3" min="2" max="10"></div>
                            <div class="form-group"><label>Columnas:</label><input type="number" id="paramCols" value="3" min="2" max="10"></div>`;
                    break;
                case 'fullmesh':
                    html = `<div class="form-group"><label>N√∫mero de nodos:</label><input type="number" id="paramNodes" value="4" min="2" max="10"></div>`;
                    break;
            }

            modalBody.innerHTML = html;
            document.getElementById('topologyModal').classList.add('active');
        }

        function createTopology() {
            updateVisibleArea();

            let offsetX = 0;

            if (nodes.length > 0) {
                const nodesInView = nodes.filter(n =>
                    n.x >= visibleX && n.x <= visibleX + 500 &&
                    n.y >= visibleY && n.y <= visibleY + 500
                );

                if (nodesInView.length > 0) {
                    const maxX = Math.max(...nodesInView.map(n => n.x));
                    offsetX = maxX - visibleX + 250;
                }
            }

            const centerX = visibleX + offsetX + 250;
            const centerY = visibleY + 250;

            switch (currentTopologyType) {
                case 'star':
                    createStarTopology(centerX, centerY);
                    break;
                case 'tree':
                    createTreeTopology(centerX, centerY);
                    break;
                case 'ring':
                    createRingTopology(centerX, centerY);
                    break;
                case 'bus':
                    createBusTopology(centerX, centerY);
                    break;
                case 'mesh':
                    createMeshTopology(centerX, centerY);
                    break;
                case 'fullmesh':
                    createFullMeshTopology(centerX, centerY);
                    break;
            }

            document.getElementById('topologyType').textContent = 'M√∫ltiple';
            closeModal('topologyModal');
        }

        function createStarTopology(cx, cy) {
            const n = parseInt(document.getElementById('paramNodes').value);
            const radius = 150;
            const center = createNodeAt(cx, cy, { name: 'PC0-t0', type: 'pc' });
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                const node = createNodeAt(x, y, { name: `PC${i + 1}-t0`, type: 'pc' });
                createConnection(center, node);
            }
        }

        function createTreeTopology(cx, cy) {
            const levels = parseInt(document.getElementById('paramLevels').value);
            let currentY = cy - 100;
            let levelNodes = [];
            let nodeIndex = 0;
            for (let level = 0; level < levels; level++) {
                const nodesInLevel = Math.pow(2, level);
                const spacing = 300 / (nodesInLevel + 1);
                const newLevelNodes = [];
                for (let i = 0; i < nodesInLevel; i++) {
                    const x = cx - 150 + spacing * (i + 1);
                    const y = currentY;
                    const node = createNodeAt(x, y, { name: `PC${nodeIndex++}-t${level}`, type: 'pc' });
                    newLevelNodes.push(node);
                    if (level > 0) {
                        const parentIndex = Math.floor(i / 2);
                        createConnection(levelNodes[parentIndex], node);
                    }
                }
                levelNodes = newLevelNodes;
                currentY += 100;
            }
        }

        function createRingTopology(cx, cy) {
            const n = parseInt(document.getElementById('paramNodes').value);
            const radius = 150;
            const ringNodes = [];
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                const node = createNodeAt(x, y, { name: `PC${i}-t0`, type: 'pc' });
                ringNodes.push(node);
            }
            for (let i = 0; i < ringNodes.length; i++) {
                createConnection(ringNodes[i], ringNodes[(i + 1) % ringNodes.length]);
            }
        }

        function createBusTopology(cx, cy) {
            const n = parseInt(document.getElementById('paramNodes').value);
            const spacing = 120;
            const startX = cx - ((n - 1) * spacing) / 2;
            const busNodes = [];
            for (let i = 0; i < n; i++) {
                const x = startX + i * spacing;
                const node = createNodeAt(x, cy, { name: `PC${i}-t0`, type: 'pc' });
                busNodes.push(node);
            }
            for (let i = 0; i < busNodes.length - 1; i++) {
                createConnection(busNodes[i], busNodes[i + 1]);
            }
        }

        function createMeshTopology(cx, cy) {
            const rows = parseInt(document.getElementById('paramRows').value);
            const cols = parseInt(document.getElementById('paramCols').value);
            const spacing = 100;
            const startX = cx - ((cols - 1) * spacing) / 2;
            const startY = cy - ((rows - 1) * spacing) / 2;
            const meshNodes = [];
            for (let r = 0; r < rows; r++) {
                meshNodes[r] = [];
                for (let c = 0; c < cols; c++) {
                    const x = startX + c * spacing;
                    const y = startY + r * spacing;
                    const node = createNodeAt(x, y, { name: `PC${r}-${c}`, type: 'pc' });
                    meshNodes[r][c] = node;
                }
            }
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (c < cols - 1) createConnection(meshNodes[r][c], meshNodes[r][c + 1]);
                    if (r < rows - 1) createConnection(meshNodes[r][c], meshNodes[r + 1][c]);
                }
            }
        }

        function createFullMeshTopology(cx, cy) {
            const n = parseInt(document.getElementById('paramNodes').value);
            const radius = 150;
            const fullMeshNodes = [];
            for (let i = 0; i < n; i++) {
                const angle = (2 * Math.PI * i) / n;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                const node = createNodeAt(x, y, { name: `PC${i}-t0`, type: 'pc' });
                fullMeshNodes.push(node);
            }
            for (let i = 0; i < fullMeshNodes.length; i++) {
                for (let j = i + 1; j < fullMeshNodes.length; j++) {
                    createConnection(fullMeshNodes[i], fullMeshNodes[j]);
                }
            }
        }

        function exportJSON() {
            const topologyName = document.getElementById('topologyName').value || 'topology';
            const sequence = connections.map(conn => {
                const node1 = nodes.find(n => n.id === conn.from);
                const node2 = nodes.find(n => n.id === conn.to);
                return `(${node1.name},${node2.name})`;
            });
            const data = {
                name: topologyName,
                description: document.getElementById('topologyDescription').value || '',
                topology_type: document.getElementById('topologyType').textContent.toLowerCase(),
                nodes: nodes.map(node => ({ id: node.id, name: node.name, type: node.type, image: node.image, flavor: node.flavor, x: node.x, y: node.y, interfaces: node.interfaces })),
                connections: connections.map(conn => ({ id: conn.id, name: conn.name, from: conn.from, to: conn.to })),
                sequence: `Seq = [${sequence.join(', ')}]`,
                metadata: { node_count: nodes.length, connection_count: connections.length, created: new Date().toISOString() }
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${topologyName.replace(/\s+/g, '_')}.json`;
            a.click();
            URL.revokeObjectURL(url);
            alert('JSON exportado exitosamente');
        }

        function importJSON(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const data = JSON.parse(e.target.result);
                    clearAll(false);
                    data.nodes.forEach(nodeData => {
                        const node = { id: nodeData.id, name: nodeData.name, type: nodeData.type, image: nodeData.image || 'cirros', flavor: nodeData.flavor || '2GBRAM_2VCPUS_10GBRoot', x: nodeData.x, y: nodeData.y, interfaces: nodeData.interfaces || [] };
                        nodes.push(node);
                        renderNode(node);
                    });
                    data.connections.forEach(connData => {
                        const connection = { id: connData.id, name: connData.name, from: connData.from, to: connData.to };
                        connections.push(connection);
                        renderConnection(connection);
                    });
                    document.getElementById('topologyName').value = data.name || '';
                    document.getElementById('topologyDescription').value = data.description || '';
                    document.getElementById('topologyType').textContent = data.topology_type || 'Importada';
                    updateStats();
                    alert('Topolog√≠a importada exitosamente');
                } catch (error) {
                    alert('Error al importar: ' + error.message);
                }
            };
            reader.readAsText(file);
            input.value = '';
        }

        function validateTopology() {
            const errors = [];
            if (nodes.length === 0) errors.push('La topolog√≠a debe tener al menos un nodo');
            const isolatedNodes = nodes.filter(node => node.interfaces.length === 0);
            if (isolatedNodes.length > 0 && nodes.length > 1) errors.push(`Hay ${isolatedNodes.length} nodo(s) sin conexi√≥n`);
            if (!document.getElementById('topologyName').value) errors.push('El nombre es requerido');
            if (errors.length > 0) {
                alert('Errores:\n' + errors.join('\n'));
                return false;
            }
            alert('Topolog√≠a v√°lida');
            return true;
        }

        async function sendToSliceManager() {
            if (!validateTopology()) return;
            const topologyData = buildSliceManagerJSON();
            try {
                const response = await fetch(SLICE_MANAGER_CONFIG.url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...(SLICE_MANAGER_CONFIG.apiKey && { 'Authorization': `Bearer ${SLICE_MANAGER_CONFIG.apiKey}` }) },
                    body: JSON.stringify(topologyData)
                });
                if (response.ok) {
                    const result = await response.json();
                    alert('Topolog√≠a enviada exitosamente');
                    return result;
                } else {
                    throw new Error(`Error ${response.status}`);
                }
            } catch (error) {
                alert(`Error: ${error.message}\n\nVerifica la URL del Slice Manager.`);
            }
        }

        function buildSliceManagerJSON() {
            const topologyName = document.getElementById('topologyName').value || 'topology';
            return {
                name: topologyName,
                description: document.getElementById('topologyDescription').value || '',
                topology_type: document.getElementById('topologyType').textContent.toLowerCase(),
                nodes: nodes.map(node => ({ id: node.name, name: node.name, type: node.type, image: node.image, flavor: node.flavor, position: { x: node.x, y: node.y } })),
                links: connections.map(conn => {
                    const node1 = nodes.find(n => n.id === conn.from);
                    const node2 = nodes.find(n => n.id === conn.to);
                    return { id: conn.name, source: node1.name, target: node2.name, bandwidth: "1Gbps" };
                }),
                metadata: { node_count: nodes.length, link_count: connections.length, created: new Date().toISOString(), editor_version: "1.0" }
            };
        }

        function zoomIn() {
            if (zoomLevel < 2) {
                zoomLevel += 0.1;
                applyZoom();
            }
        }

        function zoomOut() {
            if (zoomLevel > 0.5) {
                zoomLevel -= 0.1;
                applyZoom();
            }
        }

        function resetZoom() {
            zoomLevel = 1;
            applyZoom();
        }

        function applyZoom() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${zoomLevel})`;
            document.getElementById('zoomLevel').textContent = `${Math.round(zoomLevel * 100)}%`;
        }

        function clearAll(confirm = true) {
            if (confirm && nodes.length > 0) {
                if (!window.confirm('¬øSeguro de limpiar todo?')) return;
            }
            const canvas = document.getElementById('canvas');
            canvas.innerHTML = '';
            nodes = [];
            connections = [];
            nodeIdCounter = 0;
            connectionIdCounter = 0;
            updateStats();
            document.getElementById('topologyType').textContent = 'Personalizada';
        }

        function updateStats() {
            document.getElementById('nodeCount').textContent = nodes.length;
            document.getElementById('linkCount').textContent = connections.length;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
            currentEditNode = null;
            currentTopologyType = null;
        }

        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                if (linkMode) {
                    linkMode = false;
                    document.getElementById('canvas').style.cursor = 'default';
                    if (linkSource) {
                        document.getElementById(linkSource.id).classList.remove('selected');
                        linkSource = null;
                    }
                }
                hideNodeMenu();
                document.querySelectorAll('.modal.active').forEach(modal => modal.classList.remove('active'));
            } else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                exportJSON();
            }
        });

        document.addEventListener('click', function (e) {
            if (!e.target.closest('.node-menu') && !e.target.closest('.node')) {
                hideNodeMenu();
            }
        });

        console.log('Editor de topolog√≠as VNRT cargado correctamente.');
    </script>
</body>

</html>